\documentclass[journal]{IEEEtran}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{todonotes}	%todonotes für die toto-annotationen im Text und in der Datei

%% BIBLATEX EINBINDEN 
\usepackage[backend=bibtex]{biblatex} 
\bibliography{refs}

\title{Kooperative, verteilte Überwachung eines Gebiets auf Eindringlinge}		%Beschriftung für Titelblatt
\author{Dennis Lisiecki, Torsten Kühl}								%Ebenso, nur kleiner

\begin{document}	%Hier beginnt das Dokument

\maketitle	%Titelblatt erstellen
%\tableofcontents	%Inhaltsverzeichnis erstellen....NICHT

%\chapter{Einleitung}



\section{Einleitung} \todo[inline]{Tottis Baustelle}
Ziel ist es, mithilfe von zwei oder mehr Rasperry Pis, die jeweils mit Kamera und Infrarot-Sensoren bestückt sind, ein Gebiet oder Raum auf unerwünschte Eindringlinge zu überprüfen.\\ Die Geräte sollen dazu an unterschiedlichen Stellen platziert werden, die den zu überwachenden Raum aus unterschiedlichen Blickwinkeln zeigen. Die Kamera des jeweiligen Geräts soll nun auf jegliche wahrgenommene Bewegung reagieren. Um unerwünschte Alarme auszuschließen, soll die Kamera außerdem mit dem Infrarot-Sensor, ("PIR-Sensor") kooperieren. \\  Der PIR-Sensor kommt immer dann zum Einsatz, wenn die Kamera eine Bewegung wahrgenommen hat. Wenn nun durch die Kamera eine Bewegung erkannt und diese ebenfalls durch den PIR-Sensor wahrgenommen wurde, soll ein Alarm dafür sorgen, dass eine Mitteilung an das Handy des Benutzers geschickt wird und dieser entsprechend informiert wird. In diesem Fall ist die Wahrscheinlichkeit, dass es sich um eine Lebensform handelt, sehr groß.\\ Um eine noch höhere Genauigkeit zu erzielen, sollen die Geräte miteinander kommunizieren:\\ Eine einzelne wahrgenommene Bewegung durch die Kamera eines einzelnen Raspberry Pi stellt das geringste Risiko dar. Zwei unterschiedliche Raspberry Pis, welche mit Kamera und PIR-Sensor eine Bewegung feststellen, stellen das höchste Risiko dar.




\section{System}\todo[inline]{Tottis Baustelle}
\subsection{Raspberry Pi}
Der Raspberry Pi, welcher in unserem Projekt die Grundlage bildet, ist ein voll funktionsfähiger PC im Scheckkartenformat. In erster Linie wurde der Raspberry Pi mit dem Ziel entwickelt, interessierten Menschen das erlernen von hardwarenaher Programmierung zu erleichtern. Jedes Gerät besitzt ein frei programmierbares General Purpose Input Output-Board ("GPIO-Board"). Das GPIO-Board stellt je nach Modell 26 oder 40 Pins zur Verfügung, von denen 17 bzw. 26 Pins frei programmierbar sind und die weiteren der Spannungsversorgung oder als Masse dienen. Die einzelnen Pins dieses Boards lassen sich mit selbst programmierten Programmen ansteuern und können vielseitigen Zwecken dienen. So kann diverse externe Peripherie angesteuert werden, wie z.B. ein Temperatur-Sensor, ein Ultraschall-Sensor, ein Motor oder sogar ein kleiner externen Monitor mit Touch-Funktion. Als Betriebssystem können unter anderem an die Architektur angepasste Linux-Distributionen wie das auf Debian basierende \textit{Raspbian} installiert werden.  Auch Betriebssysteme, welche den Raspberry Pi zum Mediencenter umfunktionieren, um damit Filme und Musik abzuspielen, sind von der Community mittlerweile zur Verfügung gestellt worden. Wie solche Projekte zeigen, ist der Raspberry Pi nicht nur zum lernen gut geeignet. Die Video- und Audioausgabe erfolgt über eine HDMI-Schnittstelle, für die Audioausgabe steht alternativ auch ein 3,5mm Klinkenanschluss zur Verfügung. Für die Stromversorgung wird ein 5-V-Micro-USB-Anschluss genutzt. Hier stehen dem Anwender viele Türen offen: \\ Neben den meisten Handy-Ladegeräten kann die Stromversorgung auch über Batterie und Solarzelle erfolgen. So kann man den Raspberry Pi wirklich in alles Situationen zum Einsatz bringen. Bis dato konnte sich der Raspberry Pi knapp 4 Millionen mal verkaufen und ist inzwischen in seiner vierten Version erschienen. \cite{verkaufszahlen} Die erste Version dieses Rechner kam Anfang 2012 auf den Markt und erfreut sich seither größter Beliebtheit. Je nach Ausführung ist das Gerät zwischen 25 und 35 Euro teuer. Die unterschiedlichen Ausführungen unterscheiden sich in gewissen Punkten: \\ Modell A und A+ besitzen 256 MB Arbeitsspeicher und nur einen USB-Anschluss, Modell B und B+ besitzen 512 MB Arbeitsspeicher, eine Ethernet-Schnittstelle sowie zwei, respektive vier USB-Anschlüsse. Alle Modelle müssen ohne Festplattenschnittstelle auskommen und verwenden SD-Karten  bzw. Micro-SD-Karten als Speichermedium. Die aktuellste Version, den Raspberry Pi B+, verwenden wir für dieses Projekt.\\


\subsection{Raspberry Pi Kameramodul}
Für unser Projekt verwenden wir das Raspberry Pi Infrarot Kamera Modul ("Pi NoIR Camera Board"), weil es vom Raspberry Pi selbst auf jeden Fall unterstützt wird und der Support der Raspberry Pi Community hervorragend ist. Die Kamera bietet eine Auflösung von bis zu 5 Megapixel und kann bei statischen Aufnahmen mit einer Auflösung von bis zu 2592 x 1944 Pixel aufwarten. Mit Abmessungen von 25 x 20 x 9 mm ist die Kamera äußerst klein, muss allerdings auch ohne eigenes Gehäuse auskommen. Für die Raspberry Pi Kamera gibt es am Raspberry Pi einen eigenen Slot, in dem das Flachbandkabel der Kamera passt, sodass die GPIO-Anschlüsse am Raspberry Pi vollständig für andere Aufgaben verwendet werden können. Da die Kamera dazu in der Lage ist, Licht aus dem Infraroten Spektralbereich einzufangen, kann man auch bei schlechter Beleuchtung oder nachts noch Bewegungen erkennen lassen oder Fotos schießen. Dazu muss bei Nacht der entsprechende Bereich mit Infrarotlicht ausgeleuchtet werden. Bei vielen Überwachungskameras wird dieses Licht mittels LEDs erzeugt, welche um das Objektiv der Kamera platziert werden. Für unser Projekt sollen allerdings vorerst keine Infrarot-LEDs zum Einsatz kommen. Natürlich können zur Bewegungserkennung auch gewöhnliche USB-Webcams verwendet werden. Wir geben allerdings zu bedenken, dass das Python Script, das wir zur Bewegungserkennung verwenden, nur das Raspberry Pi Kamera Modul unterstützt. Aber auch für diesen Anwendungsfall gibt es Lösungen, die wir für die Verwendung in unserem Projekt in Betracht gezogen haben. Dazu später mehr.

\subsection{PIR-Sensor}
Beim zweiten Sensor handelt sich um ein passiven Infrarot Sensor:\\ \textit{Der PIR-Sensor (Passive Infrared Sensor) ist einer der gängigsten Bewegungsmelder und ist oftmals auch in bewegungssensitiven Außenleuchten oder Alarmanlagen verbaut. Erkennbar ist der PIR-Sensor an seiner meist runden, milchigen Kuppel, die mit vielen einzelnen Waben versehen ist. Der Sensor reagiert auf Temperaturveränderungen in seinem Sichtfeld. Somit können Menschen oder Tiere im Aktionsradius des Sensors erkannt werden. Jedoch kann der Sensor nur Veränderungen wahrnehmen. Bleibt ein Objekt ruhig im Bereich des Sensors stehen, so wird es nicht weiter erkannt.  Sobald es sich weiterbewegt, schlägt der Sensor erneut an.}\cite[S. 493]{Raspi}\\ \\ Im inneren eines solchen Moduls befinden sich zwei Folien, die an ihrer Oberfläche unterschiedliche elektrische Ladungen aufweisen. Trifft nun die Wärmestrahlung eines bestimmten Frequenzbereichs auf diese Folien, wird deren Polarisation verschoben und eine elektronische Spannung erzeugt, welche den Sensor zum auslösen bringt. Die auf den Sensor aufgesetzte "milchige Kuppel" erweitert den Erfassungsbereich des Sensors, indem es wie eine Anordnung von Linsen fungiert und lenkt die Wärmestrahlung direkt auf eine der beiden Folien. Bewegt sich nun eine Wärmequelle durch den vom Sensor überwachten Raum, kann man eine Bewegung über einen großen Bereich und in relativ großer Entfernung registrieren.\cite{pir}\todo{freies zitieren einfügen} Um den PIR Sensor am Raspberry Pi anzuschließen, werden insgesamt 3 GPIO Anschlüsse benötigt. Einen 3,3V Anschluss für die Stromversorgung, einen Ground und ein frei programmierbarer GPIO Pin, um den PIR-Sensor zu steuern.


\section{Codis: Kooperative, verteilte Überwachung}

Um eine kooperative, verteilte Überwachung zu realisieren, haben wir das Programm Codis entwickelt. Codis steht für cooperative, distributed surveillance\footnote{zu Deutsch: Kooperative, verteilte Überwachung}. In diesem Abschnitt, befassen wir uns damit, wie Codis einen Eindringling erkennt. Dazu sehen wir uns auch an, wie aus Codis ein verteiltes System entsteht und wie es als solches seine Genauigkeit beim Entdecken von Eindringlingen erhöht.

\subsection{Erkennen eines möglichen Eindringlings}

Codis verwendet für einen RasPi einen PIR-Sensor und eine Kamera. 

\subsubsection{Erkennen von Bewegungen}

Um Bewegungen zu erkennen, verwendet der H264 Kodierer des Raspberry Pis, einen simplen Algorithmus\cite{vektoren}. Der Bewegungserkennungsalgorithmus grob zusammengefasst:

\begin{itemize}
\item Es werden pro Sekunde eine festgelegte Anzahl an Bildern aufgenommen
\item Jedes Bild wird mit dem jeweils vorherigen Bild (das sog. Referenzbild) verglichen.
\item Dazu wird geschaut, an welchen Stellen sich das aufgenommene Bild und das Referenzbild am meisten ähneln. Dafür werden Bitmap ähnliche Makroböcke verwendet, um beide Bilder darzustellen und zu vergleichen.
\item Ein 2-dimensionales Array wird ausgegeben, dessen Vektoren die Punkte darstellen, die sich im Bild bewegt haben. Der Wert eines Vektors gibt das Ausmaß der Bewegung an.
\item Eine Bewegung wurde dann erkannt, wenn sich im Bild mindestens x Vektoren befinden, dessen Ausmaß an Bewegung einen Wert y nicht unterschreitet.
\end{itemize}

\subsubsection{Entdecken eines Eindringlings}


\subsection{Codis als verteiltes System}

Codis' Hauptfunktion ist es, ein Gebiet aus verschiedenen Blickwinkeln zu überwachen. Dieser Ansatz soll die Genauigkeit beim Erkennen von möglichen Eindringlingen zu erhöhen. Dazu verwendet Codis mehrere RasPis, die sich in einem Netzwerk befinden und untereinander Nachrichten austauschen. Wir verwenden im Folgenden den Begriff Codis-System für die Menge aller RasPis, auf denen Codis läuft und die miteinander in einem Netzwerk kommunizieren. Als Koordinator bezeichnen wir ein RasPi im Codis-System, der spezielle Aufgaben übernimmt, die wir im Laufe dieses Abschnittes klären. Der Koordinator ist allen RasPis im Codis-System bekannt und wird innerhalb des Codis-Systems ausgewählt. Das Codis-System wird dann erzeugt, wenn ein RasPi Codis ausführt, während kein anderer RasPi im Netzwerk Codis ausführt und wird dann zerstört, wenn Codis vom letzten RasPi im Codis-System beendet wird. Wie der Koordinator ausgewählt wird und wie wir eine kooperative, verteilte Überwachung realisieren, klären wir in den nächsten Unterabschnitten.

\subsubsection{Codis-Liste}

Codis verwendet eine verteilte Liste der IPv4-Adressen aller RasPis im Codis-System. Als verteilte Liste bezeichnen wir eine Liste, die auf allen Geräten eines verteilten Systems lokal abgespeichert ist und stets redundant zu den lokal abgespeicherten Listen der jeweils anderen Geräten ist. Die verteilte Liste, die Codis verwendet, bezeichnen wir im Folgenden als Codis-Liste. Die Codis-Liste wird zu Koordinationszwecken zwischen den RasPis im Codis-System benötigt.
Die Codis-Liste wird dann gebildet, wenn das Codis-System erzeugt wird. Möchte ein RasPi dem Codis-System beitreten, sendet dieser eine \MakeUppercase{joinrequest} Nachricht an das Codis-System. Daraufhin wartet der RasPi N Sekunden lang auf eine \MakeUppercase{joinresponse} Nachricht vom Koordinator. Die \MakeUppercase{joinresponse} Nachricht enthält die Codis-Liste und die Position des Koordinators in der Codis-Liste. Erhält der RasPi nach N Sekunden keine \MakeUppercase{joinresponse} Nachricht, trägt er sich als Erster in die Codis-Liste ein und ist somit auch der Koordinator im Codis-System. Bekommt der RasPi eine \MakeUppercase{joinresponse} Nachricht, aktualisiert er seine Codis-Liste anhand der Nachricht, trägt sich ans Ende der Codis-Liste ein und sendet eine \MakeUppercase{join} Nachricht an alle Geräte im Codis-System. Erhält ein RasPi eine \MakeUppercase{join} Nachricht, trägt er den Absender der \MakeUppercase{join} Nachricht ans Ende seiner Codis-Liste ein.

\subsubsection{Wahl eines Koordinators}

Der RasPi von dem aus das Codis-System erzeugt wurde, wird als erster Koordinator ausgewählt. Betreten weitere RasPis das Codis-System, wird ein modifizierter Ringalgorithmus\cite{verteilte1}\cite{verteilte2} ausgeführt, der alle 15 Minuten einen neuen Koordinator auswählt. Um einen logischen Ring darzustellen, verwendet Codis die Codis-Liste. Die RasPis im Codis-System sind anhand ihrer Position in der Codis-Liste aufsteigend, im Ring angeordnet. Wird ein neuer Koordinator ausgewählt, verschickt der derzeitige Koordinator eine \MakeUppercase{election} Nachricht, an seinem Nachfolger Ring. Erhält ein RasPi eine \MakeUppercase{election} Nachricht, dann trägt er sich als neuer Koordinator ein und sendet eine \MakeUppercase{coordinator} Nachricht an alle RasPis im Codis-System. Empfängt der RasPi, der die \MakeUppercase{election} Nachricht gesendet hat, nach fünf Sekunden keine \MakeUppercase{coordinator} Nachricht, sendet er drei mal in einem Interval von fünf Sekunden eine \MakeUppercase{heartbeatrequest} an seinen Nachfolger. Erhält er daraufhin eine \MakeUppercase{heartbeatresponse} Nachricht zurück, sendet er die \MakeUppercase{election} Nachricht erneut an seinen Nachfolger. Empfängt er dagegen keine \MakeUppercase{heartbeatresponse} von seinem Nachfolger, dann entfernt er diesen aus der Codis-Liste und sendet eine \MakeUppercase{listupdate} Nachricht, an das Codis-System. Danach versucht der RasPi die \MakeUppercase{election} Nachricht, an seinen nächsten Nachfolger zu senden.

\subsubsection{Abwechselnde Überwachung}

Unter abwechselnder Überwachung verstehen wir, dass nur der Koordinator das Gebiet kontinuierlich überwacht. Währenddessen gelten alle anderen RasPis als inaktiv. Inaktive RasPis haben ihre Sensoren abgeschaltet und warten auf eine \MakeUppercase{election} Nachricht. Entdeckt der Koordinator einen möglichen Eindringling, dann sendet dieser eine \MakeUppercase{intruder} Nachricht an alle anderen RasPis und geht in einen Alarmzustand über. Empfängt ein inaktiver RasPi diese Nachricht, geht dieser auch in einen Alarmzustand über. Im Alarmzustand sind die Sensoren des RasPis aktiviert. Entdeckt ein RasPi im Alarmzustand für fünf Minuten keinen Eindringling, dann geht er wieder in den inaktiven Zustand, außer der Koordinator der den Alarmzustand lediglich verlässt. Wird ein RasPi im Alarmzustand zum Koordinator, verbleibt er im Alarmzustand. Wird ein neuer Koordinator gewählt, verbleibt der vorherige Koordinator im Alarmzustand, falls er sich in diesem bereits befindet.

\subsubsection{Erkennen von Eindringlingen in einem verteilten System}



\section{Andere Ansätze (bzw. Verwandte Arbeiten)}
Zu Beginn des Projekts haben wir als Grundlage für die Bearbeitung das Programm Motion\cite{motion} als passend angesehen. Mit Motion ist es möglich, seinen (Linux-)Rechner mit USB-Kamera in eine Überwachungskamera mit vielen zusätzlichen Funktionen zu verwandeln und war aus diesem Grund für uns von Interesse. Die Konfigurationsmöglichkeiten sind sehr umfangreich und die Bewegungserkennung in der Software hat auf Wunsch Videos und/oder Fotos aufgezeichnet, sobald der Algorithmus eine Bewegung wahrgenommen hat. Bei der Aufzeichnung von Videos können die Auflösung und die Framerate selber bestimmt werden, bei Fotos kann ebenfalls die Auflösung an eigene Bedürfnisse angepasst werden. Auf Wunsch besteht auch die Möglichkeit, sich einen http-Stream zur Verfügung stellen zu lassen, mit welchem die Möglichkeit besteht, das aktuelle Geschehen vor der Kamera auch aus der Entfernung zu beobachten. Das Programm verzichtet vollständig auf eine grafische Oberfläche und kann als Daemon im Hintergrund ausgeführt werden. Also muss man auch als lokaler Anwender auf den http-Stream zugreifen, um das aktuelle Bild abzugreifen und das Geschehen dort einzusehen. Da Motion mit handelsüblichen USB-Webcams in Betrieb genommen werden kann, konnten wir das Programm sofort erproben: \\ Wir haben die Softwarepakete zu Motion also auf den Raspberry Pi installiert, eine USB-Webcam angeschlossen und konnten die Bewegungserkennung testen. Um eine ausreichende Qualität der bei Bewegung automatisch erstellten Fotos und Videos zu erreichen, musste die Auflösung hoch genug sein, was zu ersten Problemen führte: Der Raspberry Pi war mit der Speicherung der Daten sehr ausgelastet und auch der Algorithmus zur der Bewegungserkennung forderte bei entsprechend hoher Auflösung, und damit einhergehender Genauigkeit, seinen Tribut. Das System wäre dauerhaft bei einer CPU-Auslastung zwischen 80 - 100\%. Zu diesem Zeitpunkt betrachteten wir dies als notwendiges übel und fuhren trotzdem fort. Um den Anforderungen unseres Projekts gerecht zu werden, auch bei Nacht Bewegungen zu erkennen, musste allerdings ein anderes Kamerasystem genutzt werden. Das bereits vorgestellte Raspberry Pi Kameramodul wurde diesen Anforderungen gerecht, allerdings unterstützt Motion, wie erwähnt, nur USB-Kameras. In der Raspberry Pi Community war man sich dessen bereits bewusst, weshalb eine modifizierte Version von Motion existiert, mit welcher auch das Raspberry Pi Kamera Modul genutzt werden kann. Auch hier gab es leider Probleme mit der Performance, ein anderes Problem führte allerdings erst dazu, dass wir die Arbeiten mit Motion letztlich eingestellt haben: Sowohl vor, als auch nach der Modifizierung des Quellcodes von Motion gab es bei der Kompilierung viele Systemseitige Fehler, welche auch nach viel investierter Zeit nicht vollständig auszumerzen waren. Die Konfigurationsdatei zu verändern, mit welcher z.B. die Auflösung und der http-Stream eingestellt werden konnten, half uns bei dem Ziel nicht weiter, ein verteiltes Überwachungssystem zu erstellen und wir waren nicht in der Lage, den Pir-Sensor mit Motion überhaupt anzusteuern. Das Ziel war nicht erreichbar ohne den in C geschriebenen Quellcode auch dahingehend anzupassen. \\ Um einem erneuten Rückschlag vorzubeugen haben wir uns dann dazu entschlossen, mit der Programmierung eines eigenem Python-Codes zu beginnen. Die aus dem Motion-Quellcode bezogenen Erfahrungen zu dem Algorithmus der Bewegungserkennung konnten wir für unseren eigenen Ansatz gut berücksichtigen. Im Internet konnte ein recht minimalistischer Beispielcode für die Bewegungserkennung mit dem Raspberry pi Kamera Modul gefunden werden\cite{motioncode} und durch die öffentlich zugänglichen Projekte aus der Raspberry-Community konnten Lehren daraus gezogen werden, wie man einen möglichst effektiven Algorithmus schreibt, der unseren Ansprüchen genügt. In dem Buch \"Raspberry Pi - Das umfassende Handbuch\" konnte ein Beispiel für das Arbeiten mit dem PIR-Sensor gefunden werden\cite[S. 495]{Raspi}, welchen wir teilweise in unseren Code übernehmen konnten. Die Ideen und Beispiele haben wir dazu genutzt, überhaupt ein Gespür für die Programmierung mit Python zu erlangen und unsere eigenen Ideen endlich in das Projekt einbringen zu können. \\



\section{Evaluation}\todo[inline]{Dennis Baustelle}




\section{Zusammenfassung}\todo[inline]{Tottis Baustelle}
Für jeden von uns war das Thema Raspberry Pi ein nahezu unbeschriebenes Blatt. Von der Existenz des Gerätes haben wir gewusst, welche Ideen mit dem Gerät verwirklicht werden können, beginnen wir gerade zu begreifen. Nachdem wir anfangs davon ausgingen, mit Motion bereits ein sehr gut funktionierendes Softwaregerüst entdeckt zu haben, haben wir dementsprechend hohe Ziele gesteckt. Immerhin konnte davon ausgegangen werden, dass es nicht nötig war sich um den Algorithmus zur Bewegungserkennung und anderen Funktionen selbst zu kümmern. An den richtigen Stellen im Quellcode eingesetzt, hätten viele kleine Features (wie ein Motorbetriebener Schwenkvorgang der Kamera) verwirklicht werden können, denn für vieles ist Motion auch bereits gut genug designed. 




\printbibliography

\end{document}



%\chapter{Technische Realisierung}
%\section{Benötigte Bauteile}
%\begin{itemize}
%\item Raspberry Pi B+ \textit{33,70 EUR} 
%\item SD-Karte 8GB \textit{7 EUR}
%\item PiNoIR Kamera \textit{24,58 EUR}
%\item PIR-Sensor \textit{3,99 EUR}
%\item Steckplatine \textit{2,33 EUR}
%\item Kabel \textit{2,01 EUR}
%\end{itemize}
%
%Somit kommt man pro Einheit auf Materialkosten von ca 58 Euro.



%\chapter{Theoretische Herangehensweise}
